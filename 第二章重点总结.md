# 第二章 索引
### 数据表格

|   ID | School | Class | Gender |  Address | Height | Weight | Math | Physics |
| ---: | -----: | ----: | -----: | -------: | -----: | -----: | ---: | ------: |
| 1101 |    S_1 |   C_1 |      M | street_1 |    173 |     63 | 34.0 |      A+ |
| 1102 |    S_1 |   C_1 |      F | street_2 |    192 |     73 | 32.5 |      B+ |
| 1103 |    S_1 |   C_1 |      M | street_2 |    186 |     82 | 87.2 |      B+ |
| 1104 |    S_1 |   C_1 |      F | street_2 |    167 |     81 | 80.4 |      B- |
| 1105 |    S_1 |   C_1 |      F | street_4 |    159 |     64 | 84.8 |      B+ |



## 单层索引切片

### Series

`s = pd.Series(df['Math'], index=df.index)`

| 索引     | []                                                           |
| -------- | ------------------------------------------------------------ |
| 单元素   | s[1101] # 索引标签                                           |
| 单行     | s[0:4] # 绝对位置的整数                                      |
| 布尔索引 | s[s>80] # 值                                                 |
| 函数索引 | s[lambda x: x.index[16::-6]] # 绝对位置<br />s[lambda x: [1101, 1104]] # 索引值 |

注意：

1. 注意使用lambda函数时，直接切片(如：`s[lambda x: 16::-6])`就报错，直接切片使用的不是绝对位置切片，而是元素切片；
2. 如果不想陷入困境，**勿在行索引为浮点时使用`[]`操作符**，因为在`Series`中`[]`的浮点切片并不是进行位置比较，而是值比较。

```python
> s_int = pd.Series([1,2,3,4],index=[1,3,5,6])
> s_float = pd.Series([1,2,3,4],index=[1.,3.,5.,6.])
> s_int
1    1
3    2
5    3
6    4
dtype: int64

> s_int[2:]
5    3
6    4
dtype: int64

> s_float
1.0    1
3.0    2
5.0    3
6.0    4
dtype: int64

# 注意和s_int[2:]结果不一样，因为2这里是元素值而不是位置
> s_float[2:]
3.0    2
5.0    3
6.0    4
dtype: int64
```



### DataFrame

| 行、列                       | loc                                                  | iloc                           | []   |
| ---------------------------- | ---------------------------------------------------- | ------------------------------ | ---- |
| 单行                         | df.loc[1103]                                         | df.iloc[3] | df[1:2] # 整数位置<br />in_val = df.index.get_loc(1102) # 索引值<br/> df[in_val:in_val+1] |
| 多行                         | df.loc[[1102, 2304]]                                 | df.iloc[3:5] | df[3:5] #推荐用loc |
|                              | df.loc[1304:]                                        | df.iloc[3:] |      |
|                              | df.loc[2402::-1]                                     | df.iloc[3::-1] |      |
| 单列                         | df.loc[:, 'Height']                                  | df.iloc[:,3] | df['School'] |
| 多列 | df.loc[:, ['Height', 'Math']]                        | df.iloc[:,7::-2] | df[['School', 'Math']] |
|                              | df.loc[:, 'Height':'Math']                           |                                |      |
| 行列联合                     | df.loc[1102:2401:3, 'Height':'Math']                 | df.iloc[3::4,7::-2] |      |
| 布尔索引                     | df.loc[df['Address'].isin(['street_7', 'street_4'])] <u>*(Series或ndarray)*</u> | df.iloc[(df['School']=='S_1').values]        <u>*(仅ndarray)*</u> | df[df['Gender']=='F'] |
|                              | df.loc[(df['Address'] == 'street_7') \| (df['Address'] == 'street_4'), df['Physics']] | df.loc[(df['Address'] == 'street_7').values \| (df['Address'] == 'street_4').values] |df[~(df['Gender']=='F') & (df['Address']=='street_2')]|
| 函数索引（传入参数为整张表） | df.loc[lambda x:x['Gender']=='M']                    | df.iloc[lambda x:[3]] | df[lambda x:['Math','Physics']] |
|                              | def f(x):<br/>    return [1101,1103]<br/>df.loc[f]   |                                |      |
| 备注                     | 传入<u>**索引值**</u>子集列表、布尔列表或`ndarray`；<u>**前闭后闭**</u>（包含左右端点） | 传入<u>**索引位置**</u>整数、整数列表、布尔列表或`ndarray`或`Series`；<u>**前闭后开**</u>（右端点不包括） | 一般`[]`操作符常用于列选择或布尔选择，尽量避免行的选择；<u>**前闭后开**</u>（右端点不包括） |

注意：

1. 使用布尔索引时，iloc中接收的参数只能为或布尔列表或`ndarray`，不能使用布尔`Series`，如果要用就必须如下把values拿出来；loc接收的参数可为布尔列表、`ndarray`或`Series`；
2. 一般`[]`操作符尽量避免用于DataFrame的行选择，如必须使用，`[]`里应为行整数位置，如需使用索引值，需使用`.index.get_loc(索引值)`方法；

3. 在对DataFrame切片使用逻辑运算时，如果使用多个逻辑条件用`and`或`or`连接会报Series/Array真值不明确（ambiguous truth value of a Series/an Array）的错误。因在Pandas和NumPy中`and`和`or`需要单个真值进行运算，在此即单个的`True`或`False`，而含有两个及以上`True`或`False`的`Series`在Pandas中或`ndarray`在NumPy被认为真值不明确，因此不能用。除一些隐藏了bool calling的函数（如`any`、`all`、`filter`、`empty`……）用`Series`和`ndarray`不会出错外，对其余`Series`和`ndarray`取bool都会抛出该错误。因此，在DataFrame切片过程中需要运用多个逻辑条件时，可考虑使用进行位运算的`&`或`|`，或可替换为`np.logical_or(x, y)`或`np.logical_and(x, y)`。也可使用`query`函数，在该函数中，以下符号均合法：行列索引名、字符串、`and`、`not`、`or`、`&`、`|`、`~`、`not in`、`in`、`==`、`!=`、四则运算符

```python
# 非Pandas中
> [True, True] and [False, True]
[False, True]

# Pandas中
## 对Series用and
> pd.Series([True, True]) and pd.Series([False, True])
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "~/opt/anaconda3/lib/python3.7/site-packages/pandas/core/generic.py", line 1479, in __nonzero__
    f"The truth value of a {type(self).__name__} is ambiguous. "
ValueError: The truth value of a Series is ambiguous. Use a.empty, a.bool(), a.item(), a.any() or a.all().

## 对Series用&
> pd.Series([True, True]) & pd.Series([False, True])
0    False
1     True
dtype: bool
  
## 替换为np.logical_and
> np.logical_and(pd.Series([True, True]), pd.Series([False, True]))
0    False
1     True
dtype: bool
  
## 先使用any在用and
> (pd.Series([True, True]).any() and (pd.Series([False, True])).any())
True

# 在本例中
> df[df['Address'].isin(['street_1','street_4']) & df['Physics'].isin(['A','A+'])]
	School	Class	Gender	Address	Height	Weight	Math	Physics
ID								
1101	S_1	C_1	M	street_1	173	63	34.0	A+
2105	S_2	C_1	M	street_4	170	81	34.2	A
2203	S_2	C_2	M	street_4	155	91	73.8	A+

## 上面也可以用字典方式写，all与&的思路类似，其中的1代表按跨列方向判断是否全为True
> df[df[['Address','Physics']].isin({'Address':['street_1','street_4'], 'Physics':['A','A+']}).all(1)]
	School	Class	Gender	Address	Height	Weight	Math	Physics
ID								
1101	S_1	C_1	M	street_1	173	63	34.0	A+
2105	S_2	C_1	M	street_4	170	81	34.2	A
2203	S_2	C_2	M	street_4	155	91	73.8	A+

## 使用query函数
> df.query('(Address in ["street_6","street_7"]) and (Weight>(70+10)) and (ID in [1303,2304,2402])')
```



```python
# 真值不明确的情况举例
> a = np.array([1,2,3])
> b = np.array([1,3,2])

## 如果用 == 号判断二者元素是否完全相等
> print a==b
[True False False]

## 如果if [True, False, False]，逻辑上就不正确，要使用any()或者all()
> if any([True, False, False])
```



### 其他索引方式

#### 快速标量索引

当只需要取一个元素时，at和iat方法能够提供更快的实现：

```python
> df.at[1101,'School']
> df.loc[1101,'School']
> df.iat[0,0]
> df.iloc[0,0]
```



#### 区间索引

#####  1. 利用interval_range生成intervalIndex对象

```python
# periods参数控制区间个数，freq控制步长
> pd.interval_range(start=0,periods=8,freq=5)
IntervalIndex([(0, 5], (5, 10], (10, 15], (15, 20], (20, 25], (25, 30], (30, 35], (35, 40]],
              closed='right',
              dtype='interval[int64]')
```

##### 2. 利用cut将数值列转为区间为元素的分类变量

```python
# 如果没有类型转换，此时并不是区间类型，而是category类型
> math_interval = pd.cut(df['Math'],bins=[0,40,60,80,100])
> math_interval.head()
ID
1101      (0, 40]
1102      (0, 40]
1103    (80, 100]
1104    (80, 100]
1105    (80, 100]
Name: Math, dtype: category
Categories (4, interval[int64]): [(0, 40] < (40, 60] < (60, 80] < (80, 100]]
```



```python
> df_i = df.join(math_interval,rsuffix='_interval')[['Math','Math_interval']].reset_index().set_index('Math_interval')
> df_i.head()
ID	Math                                                                                                    Math_interval
(0, 40]	1101	34.0
(0, 40]	1102	32.5
(80, 100]	1103	87.2
(80, 100]	1104	80.4
(80, 100]	1105	84.8

# 将分裂变量转成区间变量
> df_i.index.astype('interval')
IntervalIndex([(0, 40], (0, 40], (80, 100], (80, 100], (80, 100] ... (40, 60], (40, 60], (40, 60], (60, 80], (40, 60]], closed='right', dtype='interval[int64]')
                                                                                                    # 使用overlap方法
> df_i[df_i.index.astype('interval').overlaps(pd.Interval(70, 85))]
ID	Math                                                                                                    Math_interval
(80, 100]	1103	87.2
(80, 100]	1104	80.4
(80, 100]	1105	84.8
(80, 100]	1201	97.0
(60, 80]	1202	63.5
(60, 80]	1205	68.4
(80, 100]	1302	87.7
(80, 100]	1304	85.2
(60, 80]	1305	61.7
(80, 100]	2101	83.3
(60, 80]	2104	72.2
(60, 80]	2202	68.5
(60, 80]	2203	73.8
(80, 100]	2205	85.4
(60, 80]	2301	72.3
(60, 80]	2303	65.9
(80, 100]	2304	95.5
(60, 80]	2404	67.7
```



## 多层索引

### slice切片问题

```python
> idx = pd.IndexSlice()
# idx([level0, level1])里面需要按顺序写
> idx(['A':'F':2, 'c'])
# 'A'：起始，'F'：终止，'2'：步长
(Slice['A', 'F', '2'], Slice('c', None, None))
```

```
占
位
```
待后续补充完成……




## 参考资料

1. [Datawhale - Pandas教程 - 第二章](https://github.com/datawhalechina/joyful-pandas/blob/master/%E7%AC%AC2%E7%AB%A0%20%E7%B4%A2%E5%BC%95.ipynb)
2. [Python 中（&，|）和（and，or）之间的区别](https://blog.csdn.net/weixin_40041218/article/details/80868521)
3. [python中&和and的区别及三目运算符的实现](https://blog.csdn.net/songyunli1111/article/details/79327137)
4. [StackOverflow: Truth value of a Series is ambiguous. Use a.empty, a.bool(), a.item(), a.any() or a.all()](https://stackoverflow.com/questions/36921951/truth-value-of-a-series-is-ambiguous-use-a-empty-a-bool-a-item-a-any-o)
5. [学习随笔-ValueError](https://blog.csdn.net/sinat_33563325/article/details/79868109)


